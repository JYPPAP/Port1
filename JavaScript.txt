JavaScript

표현식 && 표현식
둘다 참 일때만 참이다.
표현식은 앞에 먼저 평가하고, 뒤에를 평가한다.
앞 표현식을 평가해서 참 일때만, 뒤 표현식을 평가할 필요가 생기기 때문에 뒤에 표현식이 실행된다.
let n = 5;
n % 5 === && console.log('5로 나누어 떨어질때만 실행');

n이 5일때만 뒤에 로그출력이 실행되고,
그렇지 않으면 출력되지 않는다.

표현식 || 표현식
둘 중에 하나만 참이면 참이다.
앞 표현식을 평가해서 참이면, 뒤 표현식을 평가할 필요가 없어서 실행하지 않는다.
앞 표현식을 평가해서 거짓 일때만, 뒤 표현식을 평가할 필요가 생기기 때문에 뒤의 표현식이 실행된다.

function asdf () {}
는 선언적 함수 방식이다.
선언적 함수 방식은 변수 asdf를 선언한 곳보다 위 쪽에서 사용해도 정상적으로 동작한다.

하지만.
var asdf = function () {}
는 익명함수로 선언을 하고 변수에 넣은 상태이므로 
위쪽에서 사용할 수 없고, 함수의 아래쪽에서 사용할 수 있게 된다.
 
const asdf = function () {}
이것 또한 마찬가지이다. 다만 이것은 정의되지 않은 것으로 출력되지만
위쪽의 var 로 만든 것은 정의할 수 없음?? 으로 표시된다.
어쨌든 둘 다 선언보다 위 쪽에서 사용할 수 없다.

const hello = new Function();
생성자 함수로 함수를 만드는 방법
익명함수로 만드는 방법과 비슷하다. 잘 사용하지는 않는다.
const sum = new Function('a', 'b', 'c', 'return a + b + c)
와 같이 문자열의 형태로 들어간다.
함수의 바디도 안에 들어간다.

사용은 console.log(sum(1, 2, 3));
의 형태로 함수명(인자들)의 형태로 실행할 수 있다.

생성자로 만드는 것(Function)과 그냥 만드는 것(function)의 차이점은
생성자로 만드는 함수는 지역변수의 값이 아닌 전역변수의 값을 가져온다.

ES6
에로우 함수
const hello1 = (매개변수) => {
	함수의 바디
	console.log('hello1);
};
선언적 방식으로는 사용할 수 없게 된다.
항상 익명함수의 형태이고, 변수에 담아서 사용할 수 있다.
매개변수가 하나일 때 괄호를 생략할 수 있다.
const hello2 = name => {
	console.log(asdf);
}

const hello3 = (name, age) => {
	log(asdf);
};

함수의 리턴
const hello4 = name => {
	return `hello4 ${name}`;
}

const hello5 = name => `hello5 ${name}`;
와 같이 사용할 수 도 있다.
함수 자체가 간단해진다.
다른 로직이 있다면(여러줄 이라면) 한줄로 만들 수 있다.

new 함수();
생성자 함수

function Person (name, age) {
	this.name = name;
	this.age = age;
}

const p = new Person('Mark', 37);

객체를 만드는 방법. Person함수 안에 this가 있기 때문이다.

애로우 함수는 this를 만들 수 없다.

함수를 인자로 하여 함수를 호출
function hello(c) {
	log('hello);
	c();
}

hello(function() {
	log('콜백');
});

# 객체

함수, 클래스(틀) => 객체, 개체, object > 인스턴스
function 틀() {} => new 틀()
