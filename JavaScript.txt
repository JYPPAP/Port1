JavaScript

표현식 && 표현식
둘다 참 일때만 참이다.
표현식은 앞에 먼저 평가하고, 뒤에를 평가한다.
앞 표현식을 평가해서 참 일때만, 뒤 표현식을 평가할 필요가 생기기 때문에 뒤에 표현식이 실행된다.
let n = 5;
n % 5 === && console.log('5로 나누어 떨어질때만 실행');

n이 5일때만 뒤에 로그출력이 실행되고,
그렇지 않으면 출력되지 않는다.

표현식 || 표현식
둘 중에 하나만 참이면 참이다.
앞 표현식을 평가해서 참이면, 뒤 표현식을 평가할 필요가 없어서 실행하지 않는다.
앞 표현식을 평가해서 거짓 일때만, 뒤 표현식을 평가할 필요가 생기기 때문에 뒤의 표현식이 실행된다.

function asdf () {}
는 선언적 함수 방식이다.
선언적 함수 방식은 변수 asdf를 선언한 곳보다 위 쪽에서 사용해도 정상적으로 동작한다.

하지만.
var asdf = function () {}
는 익명함수로 선언을 하고 변수에 넣은 상태이므로 
위쪽에서 사용할 수 없고, 함수의 아래쪽에서 사용할 수 있게 된다.
 
const asdf = function () {}
이것 또한 마찬가지이다. 다만 이것은 정의되지 않은 것으로 출력되지만
위쪽의 var 로 만든 것은 정의할 수 없음?? 으로 표시된다.
어쨌든 둘 다 선언보다 위 쪽에서 사용할 수 없다.

const hello = new Function();
생성자 함수로 함수를 만드는 방법
익명함수로 만드는 방법과 비슷하다. 잘 사용하지는 않는다.
const sum = new Function('a', 'b', 'c', 'return a + b + c)
와 같이 문자열의 형태로 들어간다.
함수의 바디도 안에 들어간다.

사용은 console.log(sum(1, 2, 3));
의 형태로 함수명(인자들)의 형태로 실행할 수 있다.

생성자로 만드는 것(Function)과 그냥 만드는 것(function)의 차이점은
생성자로 만드는 함수는 지역변수의 값이 아닌 전역변수의 값을 가져온다.

ES6
에로우 함수
const hello1 = (매개변수) => {
	함수의 바디
	console.log('hello1);
};
선언적 방식으로는 사용할 수 없게 된다.
항상 익명함수의 형태이고, 변수에 담아서 사용할 수 있다.
매개변수가 하나일 때 괄호를 생략할 수 있다.
const hello2 = name => {
	console.log(asdf);
}

const hello3 = (name, age) => {
	log(asdf);
};

함수의 리턴
const hello4 = name => {
	return `hello4 ${name}`;
}

const hello5 = name => `hello5 ${name}`;
와 같이 사용할 수 도 있다.
함수 자체가 간단해진다.
다른 로직이 있다면(여러줄 이라면) 한줄로 만들 수 있다.

new 함수();
생성자 함수

function Person (name, age) {
	this.name = name;
	this.age = age;
}

const p = new Person('Mark', 37);

객체를 만드는 방법. Person함수 안에 this가 있기 때문이다.

애로우 함수는 this를 만들 수 없다.

함수를 인자로 하여 함수를 호출
function hello(c) {
	log('hello);
	c();
}

hello(function() {
	log('콜백');
});

# 객체

함수, 클래스(틀) => 객체, 개체, object > 인스턴스
function 틀() {} => new 틀()


10분 쉬었다가
중요한거
바로바로 써먹을 
ftp계정을 만들었으니
쓰는 방법 알려주고
파일을 압축하는 방법 설명.

사용은
좌상단은 탐색기
우상단은 원격 연결된 폴더와 파일들이 나옴.

파일로 구분하면 됨.
http://wooreeweb.com/pf/사용자명(2615)
http://wooreeweb.com/pf/사용자명(2615)/Port1/로 들어가면 자동으로 index.html 파일을 찾아서 열게 된다.

이름이 길면 짧은 주소로 변환
bit.ly 에서 변환해서
모바일페이지나, QR코드를 이용해서 삽입하는 방법도 있다.

모바일로 테스트를 할 때 크롬과 모바일은 차이가 있다.
ftp에 올려서 그 주소를 가지고 모바일 기기에서 해보면 된다.
실제 모바일 기기에서 어떻게 나오는지 알 수 있게 된다.
다른 기기가 있으면 다른 기기에서 테스트 해 보는 것을 추천한다.

한글 파일명 절대 올리지 말기.
드래그 & 드랍 형태로 올릴 수 있다.

VSCode에서 압축하는 방법
JS, CSS
min.css, min.js로 만들어주는게 좋다.
플러그인이 이미 설치가 되어있는데
minify라고 있음.

CSS파일에서 커맨드팔래트 열기
> minify
min.css나 min.js를 만들 수 있다.

버전관리
나는 바꿨는데 브라우저에서 안바뀔 때
html에서 파일을 불러올 때
파일명 뒤에
?날짜나 시간으로 넘버링
?06291749 같이 구분할 수 있는 숫자값으로
수정을 했으면, 
?06291750 의 형태로 하면 된다.

vue-6 트랜지션
4번 괜찮은 것 같음. 언제 써봐야 할 것 같음.

자바스크립트에는 프로토타입 이라는게 있다.
프로토타입은 자바스크립트에서 생성자? 간의 연계를 할 때 사용되는데. 1.프로토타입 = 2.프로토타입 을 선언하면
1은 1의 인스턴스이고, 2의 인스턴스이고, Object의 인스턴스가 된다.

변수에 리터럴 방식으로 값을 넣고,
함수를 여러개 가진 상태에서
애로우 함수를 이용하면 값이 정의되지 않기 때문에 값이 "정의되지 않음" 이라고 출력되게 되기 때문에 사용에 주의해야 한다.

object라는 표준 내장 객체가 있고, Array라는 표준 내장 객체도 존재한다.
내장 객체 의 안에는 내장 함수가 있고,
예를 들어 Array 객체 안의 slice 라는 함수는
Array 안에는 들어있지만, object에는 없다.
그래서 slice를 사용하고 싶으면 Array 객체를 불러와야 한다.

내가 생성한 것에 기본 내장객체를 붙여서 사용하는 방법이다.

ES6 부터는 클래스를 사용할 수 있게되며
선언적 방식과 변수에 할당하는 2가지 방법을 사용할 수 있다.

class A {}

const B = class {};

선언적 방식은 호이스팅은 일어나지 않는다.
함수는 호이스팅이 일어나지만 클래스는 일어나지 않는다.

호이스팅이란 사용한 곳이 선언한 곳보다 위에 있지만 실행되는 것이다.

생성자를 통해서 클래스의 안에 객체를 넣어줄 수 있다.
const B = class {
	constructor(인자) {
	
	}
};
console.log(new B(인자));